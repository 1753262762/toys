# 简单图论

## July 21, 2018, riteme

***

###### 图：基本概念

图由点集和边集构成，记为 $G = (V,\,E)$，$V$ 是点集，$E$ 是边集。通常令 $n = |V|$，$m = |E|$。

---

![](assets/day7-1.svg)

---

**无向边**用 $u - v$ 表示，**有向边**用 $u \rightarrow v$ 表示。无向边可以用两条方向相反的有向边表示。

---

边可能带有权值，用来表示长度或者其他的意义。

---

无向图中与一个节点相连的边的数量称为**度数**。有向图中进入一个点的边数为**入度**，从一个点出发的边数为**出度**。

---

如果边 $e: u - v$ 的两个端点相同，则称为**自环**。某两个节点之间可能有多条边相连，这些边都称为**重边**。没有重边和自环的图是**简单图**。

-------

**路径**是一个序列 $[x_1,\,x_2,\,\dots,\,x_k]$，其中相邻两个节点之间有无向边或有向边相连。如果 $x_1 = x_k$，则称为**环**。如果路径中没有重复元素，则称为**简单路径**。

---

如果只有无向边，则 $G$ 为**无向图**；如果只有有向边，则为**有向图**。否则为**混合图**。

---

在无向图中，如果两个节点之间有路径相连则这两个节点是**连通**的。**连通块**是一个极大的点集，其中任意两个节点之间都是连通的。如果所有节点之间都是连通的，那么 $G$ 是**连通图**。

***

###### 图：存储

图的存储一般有两种方式：**邻接矩阵**和**邻接表**。

---

邻接矩阵是一个 $n \times n$ 的矩阵 $M$，如果 $u$ 和 $v$ 之间有有向边 $u \rightarrow v$，则 $M[u][v] = 1$。

---

![](assets/day7-2.png)

---

如果有非零边权，可以设 $M[u][v]$ 为边权。

---

邻接矩阵的缺点：稀疏图中查找边的效率不高，处理重边麻烦，空间复杂度 $\Theta(n^2)$。

---

邻接表类似于存储稀疏矩阵：给每个节点开一个链表，存储从这个节点出发的所有边。

---

```
struct Edge:
	int u, v, w  // 起点、终点、边权
	Edge *nxt  // 链表的下一个元素
Edge *G[N]
```

---

或者是使用 `vector`、`deque`。

***

###### 树：基本概念

树是一类特殊的连通图：由 $n$ 个点和 $n - 1$ 条边组成。

---

另一种说法：任意两个节点之间有且仅有一条简单路径。

---

![](assets/day7-3.svg)

---

~~菊花树~~ ~~Patrick!~~

-----

树可以选定**树根**，因此分为**无根树**和**有根树**。树最外围的节点被称为**叶子节点**，准确的讲，度数为 $1$ 的非根节点都是叶节点。

---

![](assets/day7-4.svg)

---

对于有根树，一个节点到根节点的简单路径的长度为这个节点的**深度**。一条边的两个端点深度会不相同，设深度小的为 $u$，深度大的为 $v$，则 $u$ 是 $v$ 的**父亲**，$v$ 是 $u$ 的**儿子**。

---

从某个节点 $v$ 的父亲开始到根节点的简单路径上所有节点都是 $v$ 的**祖先**。从 $v$ 向下走的所有节点是 $v$ 的**后代**。$v$ 的所有后代和 $v$ 以及相关的边构成一棵**子树**。

---

由多棵树组成的无向图为**森林**。

***

###### [【LG P1141】](https://www.luogu.org/problemnew/show/P1141)01 迷宫

给出一个 $n \times n$ 的 $0/1$ 矩阵。如果你站在 $0$ 上，则可以移动到上下左右相邻四格的 $1$ 处；如果站在 $1$ 上，就可以移动到相邻四格的 $0$ 上。然后有 $m$ 次询问，每次给出一个位置，问你最多可以到达多少个位置。

$n \leqslant 1000$，$m \leqslant 10^5$

---

构建一个 $n^2$ 个点的图，相邻两个数字不同的点之间连边。

---

每次询问相当于查询一个点所处的连通块的点数。

---

使用 DFS 或者 BFS 找出所有连通块：DFS 或 BFS 的过程中标记已经访问过的节点，避免重复访问。

---

时间复杂度 $\Theta(n + m)$。

***

###### [【NOIP 2014 / LG P2296】](https://www.luogu.org/problemnew/show/P2296)寻找道路

在有向图 $G$ 中，每条边的长度为 $1$。现给定起点和终点，要求找出一条最短的路径，满足这条路径上所有点的出边所指向的点都直接或间接与终点连通。

保证终点没有出边。

$n \leqslant 10^5$，$m \leqslant 2 \times 10^5$

---

将图 $G$ 中的边反向得到图 $G'$，然后从终点出发 BFS，标记所有能够直接或间接到达终点的节点。

---

所有没有被标记的点是不合法的。

---

同时需要注意，即使是被标记的点，也可能不合法。对于每个未被标记的点 $v$，枚举图 $G$ 中的每条入边 $u \rightarrow v$，可知 $u$ 不满足条件，所以 $u$ 也是不合法的。

---

由于边权都为 $1$，寻找最短路可以直接在所有的合法点上 BFS。

***

###### [【NOIP 2015 / LG P2661】](https://www.luogu.org/problemnew/show/P2661)信息传递

有 $n$ 个同学（编号为 $1$ 到 $n$ ）正在玩一个信息传递的游戏。在游戏里每人都有一个固定的信息传递对象，其中，编号为 $i$ 的同学的信息传递对象是编号为 $T_i$ 的同学。

游戏开始时，每人都只知道自己的生日。之后每一轮中，所有人会同时将自己当前所知的生日信息告诉各自的信息传递对象（注意：可能有人可以从若干人那里获取信息， 但是每人只会把信息告诉一个人，即自己的信息传递对象）。当有人从别人口中得知自己的生日时，游戏结束。请问该游戏一共可以进行几轮？

$n \leqslant 10^5$

---

转换为图论模型：在一个 $n$ 个点的有向图中，每个点只有一条出边。求出图中最小环的长度。

---

由于每个点只有一条出边，所以每个点最多处于一个环中。

---

所以最后的图大概是这个样子：

![](assets/day7-5.svg)

----

使用 DFS 来找环。但是要注意 “假环” 的情况：

![](assets/day7-6.svg)

---

如果第一次从 $u$ 出发，标记了所有蓝色节点，没有发现环。然后从 $v$ 开始，访问到了被标记的节点，但此时不能认为找到了环。必须要是当次 DFS 访问过的节点的才能认为是找到了环。

***

###### 拓扑图

没有环的无向图是森林，没有环的有向图是**拓扑图**。

---

![](assets/day7-7.svg)

***

###### 拓扑排序

拓扑图由于没有环，所以节点之间可以排出一个相对的顺序。

---

每次任意删去一个入度为 $0$ 的点，最后可以得到一个**拓扑序**。

---

![](assets/day7-8-1.svg)

----

![](assets/day7-8-2.svg)

----

![](assets/day7-8-3.svg)

----

![](assets/day7-8-4.svg)

----

![](assets/day7-8-5.svg)

----

![](assets/day7-8-6.svg)

----

![](assets/day7-8-7.svg)

----

![](assets/day7-8-8.svg)

----

![](assets/day7-8-9.svg)

----

![](assets/day7-7.svg)

---

实现非常简单，删边的时候注意下是否入度变为了 $0$。如果是则进入队列。

---

拓扑序的特点：所有点 $u$ 能到达的点的拓扑序都在 $u$ 后面。

---

另一方面，所有能够到达 $u$ 的点都在 $u$ 前面。

---

因此拓扑序可以用作 DP 的顺序。

***

###### [【LG P1137】](https://www.luogu.org/problemnew/show/P1137)旅行计划

给定拓扑图，求出以每个点为终点的最长路径的长度。

$n \leqslant 10^5$，$m \leqslant 2 \times 10^5$

---

设 $f(x)$ 为 DP 数组，对于每个进入点 $x$ 的边 $u \rightarrow x$，用 $f(u) + 1$ 来更新 $f(x)$。

---

按照拓扑序来进行 DP。

***

###### 强连通分量

无向图中连通的概念，有向图中也有。

---

**弱连通：**将有向边转为无向边，如果转换后的无向图是连通的，则原有向图是弱连通的。

---

**强连通：**如果对于任意两个点之间都至少有一条有向路径，则为强连通的。

---

CS 大佬 Tarjan 老爷爷首先给出了找有向图中所有强连通分量的算法：一个简单的 DFS。

---

最简单的强连通分量就是一个环。Tarjan 的算法的主要思想就是将找到的环全部缩起来，最后每个强连通分量就会缩成一个点。同时，缩完点后的图由于没有环，所以是一个拓扑图。

***

###### DFS 生成树

从任意一个点开始 DFS，保留所有走过的边，构成一棵树。

---

![](assets/day7-9-1.svg)

----

![](assets/day7-9-2.svg)

----

![](assets/day7-9-3.svg)

----

![](assets/day7-9-4.svg)

----

![](assets/day7-9-5.svg)

----

![](assets/day7-9-6.svg)

----

![](assets/day7-9-7.svg)

----

![](assets/day7-9-8.svg)

----

![](assets/day7-9-9.svg)

---

上图中绿色边构成了 DFS 生成树，虚线边是**非树边**。

---

有向图的非树边分为两类：一类是**返祖边**，边的终点是起点的祖先；其余的是**横跨边**。

---

每条返祖边都代表一个环，所以在 Tarjan 算法中是需要被缩点的。横跨边一般不会构成环，但是返祖边缩环之后，横跨边也有可能成为返祖边。上图就是这样的例子。

***

###### DFS 序

还可以记录下 DFS 中每个节点首次访问的时间 `dfn`：

![](assets/day7-10.svg)

---

`dfn` 就是 DFS 序。在 DFS 树上，父亲节点的 `dfn` 比儿子要小。

***

###### Tarjan 强连通分量算法

除了 `dfn` 数组外，算法还会记录 `low` 数组，用于记录 “返祖路径”。

---

![](assets/day7-11.svg)

---

正如字面意思 `low[x]` 记录的是从 $x$ 出发能到达的 DFS 序最小的祖先。DFS 序越小，找到的强连通分量越大。

---

当 `low` 等于 `dfn` 时，说明此时已经没有能够走出 DFS 子树的路径了，子树之外的部分对于子树而言是不可达的，因此强连通分量就此而止。除去子树内部已经找出的强连通分量外，其余的部分属于同一个强连通分量。

---

这个强连通分量内其余的点都是自己的后代，所以它们的 DFS 序都比自己大。为了快速访问，使用一个栈来记录所有访问过的节点。每当找到强连通分量时，就可以从栈的尾部依次弹出强连通分量里面的节点。

---

具体的细节还是看代码吧......~~我感觉我讲不清了~~

***

###### 强连通分量：实现

~~这个代码是我随手打的...~~

---

```
int cur = 0, dfn[], low[]
bool ok[]  // 是否已经出栈
function dfs(int x):
	dfn[x] = low[x] = ++cur;
	stk.push(x)
	for v in G[x]:  // 邻接表实现：遍历 x 的所有出边 x -> v
		if dfn[v] == 0:  // 还未访问过
			dfs(v)
		if not ok[v]:  // 还未出栈
			low[x] = min(low[x], low[v])
	if low[x] == dfn[x]:
		do:
			int u = stk.pop()  // 弹出来的所有 u 在同一个强连通分量内
			ok[u] = true
		until u == x
```

***

###### [【LG P3916】](https://www.luogu.org/problemnew/show/P3916)图的遍历

给出一张有向图，求出每个点能到达的点中编号最大者。

$n,\,m \leqslant 10^5$

---

之前提到过，将所有找出的强连通分量缩点后，会得到一张拓扑图。

---

对于每个强连通分量，内部的点是互相可达的。此外还需要在拓扑图上 DP，找到其他可到达的点。

---

这题还有一个贪心的做法：将图反着建，然后按编号从大到小依次 DFS，填充答案数组。

***

###### 最短路

每条边带上一个长度，最短路问题询问两点之间最短路径的长度是多少。

---

![](assets/day7-12.svg)

---

如何求解最短路呢？

***

###### 流水模型

在起点插上一根水管，如果水流速度固定，那么最短路上的水流将会最先到达终点。

---

按照时间顺序模拟水流。每个状态记录水流到达的节点和到达的时间。同时记录 `dist` 数组表示第一次水流到达的时间，也就是从起点开始的最短路径的长度。

---

为了代码方便，除起点外的 `dist` 一般初始为一个比较大的数字，如 $10^9$。

---

从初始状态开始（位置在起点并且时间为 $0$），之后每次抽出时间最短的状态，尝试向四周流水。如果流到旁边的节点的时间小于记录的 `dist`，就说明当前是更快的水流。

---

使用堆来维护时间顺序即可，时间复杂度为 $O(m \log n)$。

---

```
struct State:
	int u, t
int dist[]
heap<State> Q  // 按 t 排序的小根堆
while Q is not empty:
	s = Q.pop()
	if s.t > dist[s.u]: continue  // 略去不必要的更新
	for w, v in G[s.u]:  // 边长为 w，终点为 v
		if  dist[v] > dist[s.u] + w:
			dist[v] = dist[s.u] + w
			Q.push(new State(v, dist[v]))
```

---

这就是 Dijkstra 算法。

---

模板题：[【LG P3371】](https://www.luogu.org/problemnew/show/P3371)

***

###### 所有点对最短路

之前的算法是单源最短路，另外有一个常用的算法是 Floyd 算法，可以在 $O(n^3)$ 的时间内计算出所有点对间的最短路。

---

每一条路径都有起点和终点，此外还可能会有许多的中介点。Floyd 算法直接采用邻接矩阵记录原图 $G$，用矩阵 $W$ 表示点对间的最短路。$G$ 相当于不经过任何中介点的最短路矩阵，于是 Floyd 算法尝试不断加入中介点来更新最短路矩阵。

---

从 $1$ 开始枚举新加入的中介点 $k$，对于任意两个点 $i$ 和 $j$，其最短路有两种选择：一是保持原样，即 $W[i][j]$；二是经过新的中介点 $k$，即 $W[i][k] + W[k][j]$。两者取最小值即可。

---

```
for k in [1..n]:
	for i in [1..n]:
		for j in [1..n]:
			W[i][j] = min(W[i][j], W[i][k] + W[k][j])
```

***

###### [【LG P2935】](https://www.luogu.org/problemnew/show/P2935)Best Spot

给出一个无向带权图和 $F​$ 个特殊点，找出到这 $F​$ 个点的距离之和最短的点。

$n \leqslant 500$

---

用 Floyd 求出所有最短路后枚举。